<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=referrer content="no-referrer-when-downgrade"><meta name=coverage content="Worldwide"><meta name=distribution content="Global"><meta name=HandheldFriendly content="True"><meta name=msapplication-tap-highlight content="no"><base href=https://www.moritzfriedrich.com/posts/php-cronjobs/><link rel=canonical href=https://www.moritzfriedrich.com/posts/php-cronjobs/ itemprop=url><link rel=sitemap type=application/xml title=Sitemap href=https://www.moritzfriedrich.com/sitemap.xml><meta name=url content="https://www.moritzfriedrich.com/posts/php-cronjobs/"><meta name=twitter:url content="https://www.moritzfriedrich.com/posts/php-cronjobs/"><meta property="og:url" content="https://www.moritzfriedrich.com/posts/php-cronjobs/"><meta name=description content="moritz friedrich, yet another full-stack developer."><meta itemprop=description content="moritz friedrich, yet another full-stack developer."><meta property="og:description" content="moritz friedrich, yet another full-stack developer."><meta name=twitter:description content="moritz friedrich, yet another full-stack developer."><meta property="og:locale" content="en"><meta name=language content="en"><meta property="og:title" content="Simple Cronjobs for CLI apps using systemd | Moritz Friedrich"><meta name=twitter:title content="Simple Cronjobs for CLI apps using systemd | Moritz Friedrich"><meta itemprop=name content="Simple Cronjobs for CLI apps using systemd | Moritz Friedrich"><meta name=application-name content="Simple Cronjobs for CLI apps using systemd | Moritz Friedrich"><meta property="og:site_name" content><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:app_id" content><meta property="fb:admins" content><meta itemprop=image content="https://www.moritzfriedrich.com/"><meta property="og:image" content="https://www.moritzfriedrich.com/"><meta name=twitter:image content="https://www.moritzfriedrich.com/"><meta name=twitter:image:src content="https://www.moritzfriedrich.com/"><meta property="og:type" content="article"><meta property="article:publisher" content><meta property="og:article:published_time" content="2020-01-16T13:29:13+0100"><meta property="article:published_time" content="2020-01-16T13:29:13+0100"><meta property="og:updated_time" content="2020-01-16T13:29:13+0100"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#2b5797><meta name=msapplication-TileColor content="#2b5797"><meta name=theme-color content="#ffffff"><script defer type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Simple Cronjobs for CLI apps using systemd","description":"Most applications will need some kind of asynchronous processing happening in the background: Calculating statistics, sending emails or processing large files. These tasks are probably abstracted into some kind of job queue, ready to be fetched by a worker.\nNow, whenever you want to perform a task in regular intervals (say: Calculating monthly billing positions and sending them to Stripe for invoicing), you need some kind of scheduler. The most straightforward and probably most common solution is to simply create a cron job.","image":"https://www.moritzfriedrich.com/","datePublished":"2020-01-16T13:29:13+01:00","dateModified":"2020-01-16T13:29:13+01:00","wordCount":"1309","author":{"@type":"Person","name":""},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.moritzfriedrich.com/"},"publisher":{"@type":"Person","name":""},"keywords":["blog","story"]}</script><link rel=stylesheet href=/css/style.min.3f46e5124efcee47aa3f0e3aba4d2d0ccb5b09656fc96cb5a78f58b7ed98ff6b.css integrity="sha256-P0blEk787keqPw46uk0tDMtbCWVvyWy1p49Yt+2Y/2s=" crossorigin=anonymous media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Didact+Gothic|Fira+Code"><title>Simple Cronjobs for CLI apps using systemd</title></head><body><div class=wrap><header class=page-header id=title><h1 class=page-title>Simple Cronjobs for CLI apps using systemd</h1></header><div class=page-content id=content>Thursday, 16. January 2020 &#183; 7 minutes<div class=tags><span class=tags__tag><a href=https://www.moritzfriedrich.com/tags/blog>blog</a></span>
<span class=tags__tag><a href=https://www.moritzfriedrich.com/tags/story>story</a></span></div><p>Most applications will need some kind of asynchronous processing happening in the background: Calculating statistics, sending emails or processing large files. These tasks are probably abstracted into some kind of <em>job queue</em>, ready to be fetched by a worker.<br>Now, whenever you want to perform a task in regular intervals (say: Calculating monthly billing positions and sending them to Stripe for invoicing), you need some kind of scheduler. The most straightforward and probably most common solution is to simply create a <em>cron job</em>. While cron jobs might work for the most part, they bring lots of hidden complexity:</p><ul><li>What happens if an execution takes longer than expected and ends up still running when the next scheduled execution starts?</li><li>Where do logs go? Do you even log your cron job results? <em>All</em> of them?</li><li>How do you randomize execution times to prevent hitting a third-party API rate limit, for example?</li><li>Can you limit system resource usage for them?</li></ul><p>The solution to these and several other problems are <a class=link href="http://man.he.net/?topic=systemd+timer&section=all" target=_blank rel="noreferrer noopener">systemd&rsquo;s timers</a>
. I know hating on systemd is still fashionable as always, but whatever your opinion is, it&rsquo;s not going to go anywhere anytime soon, and timers are awesome!</p><h2 id=setting-up-a-timer class="heading heading--2"><a class=heading__anchor href=#setting-up-a-timer>Setting up a timer</a></h2><p>To get systemd to repeatedly execute something, you always need two parts:</p><ol><li><strong>A service unit.</strong> This can really be just an ordinary service unit, but for our use case, we use a minimal service configuration only. This &ldquo;service&rdquo; is the command being executed for your job - for the sake of this post, let&rsquo;s assume <code>/opt/job do-work</code>.</li><li><strong>A timer unit.</strong> As with all things systemd, timer units also live in your systemd directory (probably <code>/etc/systemd/system/</code>) and can (and must) be separately enabled. The timer is configured to execute the service if a set of conditions match.</li></ol><p>I don&rsquo;t know about your application, but mine have lots of jobs to do. Hearing this, I immediately thought how awful it&rsquo;d be to create <strong>two</strong> configuration files and type a bunch of <code>systemctl</code> commands, just to achieve the same effect as putting a single line of text in my crontab.<br>But bear with me for a moment: I promise there&rsquo;s a more elegant solution (<a class=link href=#wildcard-services>skip to the TL;DR</a>
).</p><h2 id=writing-the-service class="heading heading--2"><a class=heading__anchor href=#writing-the-service>Writing the service</a></h2><p>Say we&rsquo;re trying to execute the previously mentioned <code>/opt/job do-work</code>. The following service configuration would achieve this task:</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=k>[Unit]</span>
<span class=na>Description</span><span class=o>=</span><span class=s>job worker</span>
<span class=na>After</span><span class=o>=</span><span class=s>network.target</span>

<span class=k>[Service]</span>
<span class=na>ExecStart</span><span class=o>=</span><span class=s>/opt/job do-work </span>

<span class=k>[Install]</span>
<span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</code></pre></div><p>This snippet is pretty simple - from top to bottom:</p><ul><li>The <code>Description</code> in the unit section will be shown in the log files, so this is mostly cosmetic.</li><li>The <code>After</code> denotes that our job worker requires network access to run, so it can&rsquo;t be started before the network daemon is initialized.</li><li>The <code>ExecStart</code> contains the command we intend to execute on starting the service.</li><li>The last line, <code>WantedBy</code>, is the systemd way of saying our service requires at least runlevel 3. This is the level just below initialization of the GUI systems, so it basically means <em>&ldquo;this service requires the system to be up&rdquo;</em>.</li></ul><p>We save that service unit file as <code>/etc/systemd/system/job.service</code> for now. After executing <code>systemctl daemon-reload</code>, you should be able to run <code>systemctl start job</code> and review the log output using <code>journalctl -u job</code>.</p><h2 id=writing-the-timer class="heading heading--2"><a class=heading__anchor href=#writing-the-timer>Writing the timer</a></h2><p>Now that we have a working service, we can create the timer unit.</p><blockquote><p>As an aside, I think this is much more in line with the Unix philosophy (<em>&ldquo;Do one thing, and do it well&rdquo;</em>) than any cron approach: The job to execute and the definition of the execution schedule are two separate things, decoupling potentially complex scheduling from the act of doing a thing.</p></blockquote><p>Further assume we want to execute our command every 60 minutes, or rather: With a pause of 60 minutes between individual executions. Additionally, we&rsquo;d like to add a random delay of 0â€“30 seconds.<br>The timer unit could look like so:</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=k>[Unit]</span>
<span class=na>Description</span><span class=o>=</span><span class=s>job timer</span>

<span class=k>[Timer]</span>
<span class=na>Unit</span><span class=o>=</span><span class=s>job.service</span>
<span class=na>OnUnitInactiveSec</span><span class=o>=</span><span class=s>60m</span>
<span class=na>RandomizedDelaySec</span><span class=o>=</span><span class=s>30</span>
<span class=na>AccuracySec</span><span class=o>=</span><span class=s>1s</span>

<span class=k>[Install]</span>
<span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</code></pre></div><p>Now the timer section is the most interesting here:</p><ul><li>The <code>Unit</code> defines the service this timer will execute. It expects the name of our service unit file.</li><li>The second directive, <code>OnUnitInactiveSec</code>, is one of several possible timer settings. It accepts a time interval, basically the time to wait before starting the service again, <em>counted from the end of the previous execution</em>.</li><li><code>RandomizedDelaySec</code> instead accepts a number of seconds that a random interval will be chosen from. The execution will then be delayed by that random interval.</li><li>The last directive <code>AccuracySec</code> defines the accuracy the timer will be checked, so a lower value means the timer will fire more accurately. The minimum value is <code>1us</code>, but we probably don&rsquo;t need this much precision in our case.</li></ul><p>The timer file should be saved as <code>/etc/systemd/system/job-work.timer</code>. As with the service unit, after executing <code>systemctl daemon-reload</code>, you should be able to run <code>systemctl start job-work.timer</code>. Don&rsquo;t forget to enable the timer using <code>systemctl enable job-work.timer</code>.</p><p>To monitor when your job is going to be executed the next time, you can use <code>systemctl list-timers</code>, which will list the all timers with their last and next execution dates, the time left until the next and passed since the last one as well as the service unit being executed. A marvelous command!</p><p>After having performed the above step, we should have a running configuration, with our <code>/opt/job do-work</code> command being run approximately every hour. Phew. While you can obviously optimize scaffolding the timer setup, repeating this for <em>every single job type</em> sounds like way too much work.<br>So as promised, there&rsquo;s a better solution than lots of separate configuration files!</p><h2 id=wildcard-services class="heading heading--2"><a class=heading__anchor href=#wildcard-services>Wildcard services</a></h2><p>There exists a neat little feature in systemd to define parameterized services. If the service unit file contains an <code>@</code> character in its file name, just before the <code>.service</code>, it will be treated as a &ldquo;template unit file&rdquo;. You can then refer to the service with any characters after the <code>@</code> being treated as a dynamic parameter, available inside the unit file as <code>%i</code>. That sounds pretty confusing but is easy in practice, so let&rsquo;s transform our above setup to use the instance parameter.</p><h2 id=creating-a-wildcard-unit class="heading heading--2"><a class=heading__anchor href=#creating-a-wildcard-unit>Creating a wildcard unit</a></h2><p>To accept a parameter, we need to change the filename of our service unit to the following:</p><pre><code>/etc/systemd/system/job@.service
</code></pre><p>Inside the unit, we may now use the <code>%i</code> placeholder, which will be replaced during execution:</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=k>[Unit]</span>
<span class=na>Description</span><span class=o>=</span><span class=s>job worker for %i</span>
<span class=na>After</span><span class=o>=</span><span class=s>network.target</span>

<span class=k>[Service]</span>
<span class=na>ExecStart</span><span class=o>=</span><span class=s>/opt/job %i </span>

<span class=k>[Install]</span>
<span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</code></pre></div><p>If you scroll back up to the original service unit, all we did was replace the <code>do-work</code> subcommand with our <code>%i</code> placeholder! Now (after the usual <code>systemctl daemon-reload</code>, that is), we can start our service with the placeholder being passed dynamically on the command line!<br>To resume execution of our <code>do-work</code> command, we can call the service like so:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>systemctl start job@do-work.service
</code></pre></div><p>Behind the scenes, this will trigger the <code>ExecStart</code> command line and replace the <code>%i</code> with <code>do-work</code>. And now that we got this working, we should update our timer unit:</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=k>[Unit]</span>
<span class=na>Description</span><span class=o>=</span><span class=s>job timer</span>

<span class=k>[Timer]</span>
<span class=na>Unit</span><span class=o>=</span><span class=s>job@do-work.service</span>
<span class=na>OnUnitInactiveSec</span><span class=o>=</span><span class=s>60m</span>
<span class=na>RandomizedDelaySec</span><span class=o>=</span><span class=s>30</span>
<span class=na>AccuracySec</span><span class=o>=</span><span class=s>1s</span>

<span class=k>[Install]</span>
<span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</code></pre></div><p>Now, we can simply copy-paste the timer unit and insert our desired sub-command instead of <code>do-work</code> in the <code>Unit</code> section.<br>But wait, there&rsquo;s more!</p><h2 id=creating-a-wildcard-timer class="heading heading--2"><a class=heading__anchor href=#creating-a-wildcard-timer>Creating a wildcard timer</a></h2><p>Why stop there? We can of course also use the wildcard placeholder inside our timer!</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=k>[Unit]</span>
<span class=na>Description</span><span class=o>=</span><span class=s>job timer %i</span>

<span class=k>[Timer]</span>
<span class=na>Unit</span><span class=o>=</span><span class=s>job@%i.service</span>
<span class=na>OnUnitInactiveSec</span><span class=o>=</span><span class=s>60m</span>
<span class=na>RandomizedDelaySec</span><span class=o>=</span><span class=s>30</span>
<span class=na>AccuracySec</span><span class=o>=</span><span class=s>1s</span>

<span class=k>[Install]</span>
<span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</code></pre></div><p>Here, we replaced the sub-command with <code>%i</code> again, allowing us to use this timer dynamically for any job that should run hourly. So after saving it as <code>/etc/systemd/system/job-hourly@.timer</code> (yes, you guessed right: <code>systemctl daemon-reload</code>), we can finally start adding commands using systemctl only:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>systemctl <span class=nb>enable</span> job-hourly@first-command.timer
systemctl <span class=nb>enable</span> job-hourly@second-command.timer
systemctl <span class=nb>enable</span> job-hourly@third-command.timer
</code></pre></div><p>If you need other schedules too, simply copy-paste the wildcard unit, change the timer options and enable the timers for your desired parameter.</p><p>Finally, we have a cron-less, flexible and best practice conformant scheduler system that can be infinitely expanded and is portable. Awesome!</p></div><div class=bottom-menu><hr><nav><a href=/posts>back</a>&#183;<a href=/posts>blog</a>&nbsp;&#183;&nbsp;<a href=https://github.com/Radiergummi>github</a>&nbsp;&#183;&nbsp;<a href=/about>about</a>&nbsp;&#183;&nbsp;<a href=https://www.moritzfriedrich.com/imprint/>imprint</a>&nbsp;&#183;&nbsp;<a href=https://www.moritzfriedrich.com/privacy/>privacy</a>&nbsp;&#183;&nbsp;<a href=https://www.moritzfriedrich.com/>home</a></nav></div><div class=page-footer><script data-goatcounter=https://stats.9dev.de/count async src=https://stats.9dev.de/count.js></script><script></script></div></div></body></html>