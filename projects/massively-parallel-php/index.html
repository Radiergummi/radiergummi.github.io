<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=referrer content="no-referrer-when-downgrade"><meta name=coverage content="Worldwide"><meta name=distribution content="Global"><meta name=HandheldFriendly content="True"><meta name=msapplication-tap-highlight content="no"><base href=https://www.moritzfriedrich.com/projects/massively-parallel-php/><link rel=canonical href=https://www.moritzfriedrich.com/projects/massively-parallel-php/ itemprop=url><link rel=sitemap type=application/xml title=Sitemap href=https://www.moritzfriedrich.com/sitemap.xml><meta name=url content="https://www.moritzfriedrich.com/projects/massively-parallel-php/"><meta name=twitter:url content="https://www.moritzfriedrich.com/projects/massively-parallel-php/"><meta property="og:url" content="https://www.moritzfriedrich.com/projects/massively-parallel-php/"><meta name=description content="moritz friedrich, yet another full-stack developer."><meta itemprop=description content="moritz friedrich, yet another full-stack developer."><meta property="og:description" content="moritz friedrich, yet another full-stack developer."><meta name=twitter:description content="moritz friedrich, yet another full-stack developer."><meta property="og:locale" content="en"><meta name=language content="en"><meta property="og:title" content="Massively Parallel PHP | Moritz Friedrich"><meta name=twitter:title content="Massively Parallel PHP | Moritz Friedrich"><meta itemprop=name content="Massively Parallel PHP | Moritz Friedrich"><meta name=application-name content="Massively Parallel PHP | Moritz Friedrich"><meta property="og:site_name" content><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:app_id" content><meta property="fb:admins" content><meta itemprop=image content="https://www.moritzfriedrich.com/"><meta property="og:image" content="https://www.moritzfriedrich.com/"><meta name=twitter:image content="https://www.moritzfriedrich.com/"><meta name=twitter:image:src content="https://www.moritzfriedrich.com/"><meta property="og:type" content="website"><meta property="og:updated_time" content="2020-06-29T12:35:04+0200"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#2b5797><meta name=msapplication-TileColor content="#2b5797"><meta name=theme-color content="#ffffff"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https://www.moritzfriedrich.com/projects/massively-parallel-php/","name":"Massively Parallel PHP","logo":"https://www.moritzfriedrich.com/img/logo.png","sameAs":["https://www.instagram.com/radiergummi","https://twitter.com/@mofriedrich","https://github.com/Radiergummi"]}</script><link rel=stylesheet href=/css/style.min.1095e42e549034a714cb22436accb81b48226eeeb0d4ee5c755c0163a41bc5d5.css integrity="sha256-EJXkLlSQNKcUyyJDasy4G0gibu6w1O5cdVwBY6QbxdU=" crossorigin=anonymous media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Didact+Gothic|Fira+Code"><title>Massively Parallel PHP</title></head><body><div class=wrap><header class=page-header id=title><h1 class=page-title>Massively Parallel PHP</h1></header><main class=page-content id=content><p>With most large software systems, sooner or later a need arises to perform certain jobs in parallel. We usually solve this problem with some sort of job queue which
schedules work to be processed later, asynchronously, in a separate process. While PHP might not be the first language that jumps to mind for long-running workers,
it was still the best possible choice at MessengerPeople. How so? We have a huge ecosystem of applications, shared libraries and conventions, all built with PHP.
Being able to reuse those was an enormous benefit during development. Additionally, no matter how perfect another language may be&ndash;if your engineers don&rsquo;t know it,
they (including you) are bound to fail.<br>This lead me to creating a simple system to execute PHP code in parallel. Analyzing the situation, the wishlist included the following:</p><ul><li>Be able to spawn multiple worker threads per instance</li><li>Have worker code be oblivious of being run in a worker</li><li>Rely on existing code and conventions as much as possible</li></ul><p>At the time of building the foundation for our workers, the only way to get PHP to spawn userland threads was using
<a class=link href=https://blog.krakjoe.ninja/2019/02/parallel-php-next-chapter.html target=_blank rel="noreferrer noopener">the <code>pthreads</code> extension</a>
, which is neither safe, nor elegant, nor even easily understandable,
as even its author has written. After lots of nights spent furiously punching my keyboard, I finally managed to bend pthreads to my will; it wasn&rsquo;t pretty, but the
code got the job done. Basically, I moved all the specifics of the extension behind the curtains, and exposed a much clearer API to our applications, consisting of
tasks, workers and pools. A task is something to be executed, a worker executes such a task, and a pool consists of multiple workers executing one or more tasks.<br>All of a sudden, user-userland code is surprisingly simple:</p><div class=highlight><pre class=chroma><code class=language-php data-lang=php><span class=cp>&lt;?php</span>
<span class=k>class</span> <span class=nc>MyTask</span> <span class=k>extends</span> <span class=nx>Framework\Support\MultiTasking\Task</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>function</span> <span class=nf>run</span><span class=p>()</span><span class=o>:</span> <span class=nx>void</span> <span class=p>{</span>
        <span class=c1>// do stuff
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The task would be run in a try-catch block; if it threw an exception, it would be considered failed and restarted. If no exception was thrown, the worker shut down
cleanly, as its job was obviously done. Worker pools could be configured to use a fixed number (or proportional fraction of available) workers, and automatically
spawn replacements for any stopped workers. Behind the scenes, we would spawn a new thread for every worker and bootstrap it using the main framework entry point,
which would take care of initializing the autoloader, configuration loading and dependency injection setup. At the time the task&rsquo;s <code>run()</code> method would be called,
everything was ready and initialized, providing a clean and modularized runtime environment to every single thread.</p><p>This is definitely not the most elegant or efficient approach (every single worker keeps the same, large, runtime in memory!), but it avoids typical threading
pitfalls with shared memory and effectively prevents memory leaks PHP is pretty vulnerable to, as every reference from tasks are cleaned up on completion. Plus, and
most importantly, <em>the task implementation is so simple, anyone on the team could add new tasks to our worker application</em>.</p><p>With the &ldquo;front-end&rdquo; part done, we can boot up an application with a pool of, say, 32 worker threads, and let it handle a task that listens to our job queue. Every
worker thread listens to the RabbitMQ server for new jobs; if it crashed during handling, the message went back into the queue. As we, unsurprisingly, run all of
this within Kubernetes of course, the application runs in a Docker container which is spread out among a dynamically resized number of pods.<br>Putting all of this together, we end up with a distributed, auto-healing, dynamically resizable, completely horizontally scalable, worker system written entirely in
PHP.</p><hr><p>Now the story could end here, but of course the world doesn&rsquo;t. So as it goes, Joe Watkins (the developer of the pthreads extension) figured out there might be a better approach to threading in PHP. Thus, he started</p></main><div class=bottom-menu><hr><nav><a href=/posts>blog</a>&nbsp;&#183;&nbsp;<a href=https://github.com/Radiergummi>github</a>&nbsp;&#183;&nbsp;<a href=/about>about</a>&nbsp;&#183;&nbsp;<a href=https://www.moritzfriedrich.com/imprint/>imprint</a>&nbsp;&#183;&nbsp;<a href=https://www.moritzfriedrich.com/privacy/>privacy</a>&nbsp;&#183;&nbsp;<a href=https://www.moritzfriedrich.com/>home</a></nav></div><div class=page-footer><script data-goatcounter=https://stats.9dev.de/count async src=https://stats.9dev.de/count.js></script><script></script></div></div></body></html>